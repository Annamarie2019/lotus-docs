{"posts":[{"title":"Hardware Requirements","slug":"en+hardware","github":"en/hardware.md","value":"# Hardware\n\n> This page is a work in progress. Exact mining requirements are still in the works.\n\nLotus can build and run on most [Linux](https://ubuntu.com/) and [MacOS](https://www.apple.com/macos) systems with at least 8GiB of RAM.\n\nWindows is not yet supported.\n","posts":[{"title":"Testing Configuration","slug":"en+hardware-mining","github":"en/hardware-mining.md","value":"# Protocol Labs Standard Testing Configuration\n\n> This documentation page describes the standard testing configuration the Protocol Labs team has used to test **Lotus Storage Miner**s on Lotus. There is no guarantee this testing configuration will be suitable for Filecoin storage mining at MainNet launch. If you need to buy new hardware to join the Filecoin Testnet, we recommend to buy no more hardware than you require for testing. To learn more please read this [Protocol Labs Standard Testing Configuration post](https://filecoin.io/blog/filecoin-testnet-mining/).\n\n**Sector sizes** and **minimum pledged storage** required to mine blocks are two very important Filecoin Testnet parameters that impact hardware decisions. We will continue to refine all parameters during Testnet.\n\nBECAUSE OF THIS, OUR STANDARD TESTING CONFIGURATION FOR FILECOIN MAINNET CAN AND WILL CHANGE. YOU HAVE BEEN WARNED.\n\n## Example configuration\n\nThe setup below is a minimal example for sealing 32 GiB sectors on Lotus:\n\n- 2 TB of hard drive space.\n- 8 core CPU\n- 128 GiB of RAM\n\nNote that 1GB sectors don't require as high of specs, but are likely to be removed as we improve the performance of 32GB sector sealing.\n\nFor the first part of the sealing process, AMD CPU's are __highly recommended__, because of the `Intel SHA Extensions` instruction set that is available there ever since the `Zen` microarchitecture. Hence, AMD CPU's seem to perform much better on the testnet than other CPU's. Contrary to what the name implies, this extended instruction set is not available on recent Intel desktop/server chips. \n\n## Testnet discoveries\n\n- If you only have 128GiB of ram, enabling 256GB of **NVMe** swap on an SSD will help you avoid out-of-memory issues while mining.\n\n## Benchmarked GPUs\n\nGPUs are a must for getting **block rewards**. Here are a few that have been confirmed to generate **SNARKs** quickly enough to successfully mine blocks on the Lotus Testnet.\n\n- GeForce RTX 2080 Ti\n- GeForce RTX 2080 SUPER\n- GeForce RTX 2080\n- GeForce GTX 1080 Ti\n- GeForce GTX 1080\n- GeForce GTX 1060\n\n## Testing other GPUs\n\nIf you want to test a GPU that is not explicitly supported, use the following global **environment variable**:\n\n```sh\nBELLMAN_CUSTOM_GPU=\"<NAME>:<NUMBER_OF_CORES>\"\n```\n\nHere is an example of trying a GeForce GTX 1660 Ti with 1536 cores.\n\n```sh\nBELLMAN_CUSTOM_GPU=\"GeForce GTX 1660 Ti:1536\"\n```\n\nTo get the number of cores for your GPU, you will need to check your cardâ€™s specifications.\n\n## Benchmarking\n\nHere is a [benchmarking tool](https://github.com/filecoin-project/lotus/tree/master/cmd/lotus-bench) and a [GitHub issue thread](https://github.com/filecoin-project/lotus/issues/694) for those who wish to experiment with and contribute hardware setups for the **Filecoin Testnet**.\n"}]},{"title":"Setup","slug":"en+getting-started","github":"en/getting-started.md","value":"# Lotus\n\nLotus is an implementation of the **Filecoin Distributed Storage Network**. You can run the Lotus software client to join the **Filecoin Testnet**.\n\nFor more details about Filecoin, check out the [Filecoin Docs](https://docs.filecoin.io) and [Filecoin Spec](https://filecoin-project.github.io/specs/).\n\n## What can I learn here?\n\n- How to install Lotus on [Arch Linux](https://docs.lotu.sh/en+install-lotus-arch), [Ubuntu](https://docs.lotu.sh/en+install-lotus-ubuntu), or [MacOS](https://docs.lotu.sh/en+install-lotus-macos).\n- Joining the [Lotus Testnet](https://docs.lotu.sh/en+join-testnet).\n- [Storing](https://docs.lotu.sh/en+storing-data) or [retrieving](https://docs.lotu.sh/en+retrieving-data) data.\n- Mining Filecoin using the **Lotus Storage Miner** in your [CLI](https://docs.lotu.sh/en+mining).\n\n## How is Lotus designed?\n\nLotus is architected modularly to keep clean API boundaries while using the same process. Installing Lotus will include two separate programs:\n\n- The **Lotus Node**\n- The **Lotus Storage Miner**\n\nThe **Lotus Storage Miner** is intended to be run on the machine that manages a single storage miner instance, and is meant to communicate with the **Lotus Node** via the websocket **JSON-RPC** API for all of the chain interaction needs.\n\nThis way, a mining operation may easily run a **Lotus Storage Miner** or many of them, connected to one or many **Lotus Node** instances.\n","posts":[{"title":"Arch Linux Installation","slug":"en+install-lotus-arch","github":"en/install-lotus-arch.md","value":"# Arch Linux Instructions\n\nThese steps will install the following dependencies:\n\n- go (1.14 or higher)\n- gcc (7.4.0 or higher)\n- git (version 2 or higher)\n- bzr (some go dependency needs this)\n- jq\n- pkg-config\n- opencl-icd-loader\n- opencl driver (like nvidia-opencl on arch) (for GPU acceleration)\n- opencl-headers (build)\n- rustup (proofs build)\n- llvm (proofs build)\n- clang (proofs build)\n\nRun\n\n```sh\nsudo pacman -Syu opencl-icd-loader\n```\n\nBuild\n\n```sh\nsudo pacman -Syu go gcc git bzr jq pkg-config opencl-icd-loader opencl-headers\n```\n\nClone\n\n```sh\ngit clone https://github.com/filecoin-project/lotus.git\ncd lotus/\n```\n\nInstall\n\n```sh\nmake clean && make all\nsudo make install\n```\n\nAfter installing Lotus, you can run the `lotus` command directly from your CLI to see usage documentation. Next, you can join the [Lotus Testnet](https://docs.lotu.sh/en+join-testnet).\n"},{"title":"Ubuntu Installation","slug":"en+install-lotus-ubuntu","github":"en/install-lotus-ubuntu.md","value":"# Ubuntu Instructions\n\nThese steps will install the following dependencies:\n\n- go (1.14 or higher)\n- gcc (7.4.0 or higher)\n- git (version 2 or higher)\n- bzr (some go dependency needs this)\n- jq\n- pkg-config\n- opencl-icd-loader\n- opencl driver (like nvidia-opencl on arch) (for GPU acceleration)\n- opencl-headers (build)\n- rustup (proofs build)\n- llvm (proofs build)\n- clang (proofs build)\n\n### Install dependencies\n\n```sh\nsudo apt update\nsudo apt install mesa-opencl-icd ocl-icd-opencl-dev gcc git bzr jq pkg-config curl\nsudo apt upgrade\n```\n\n### Install Go 1.14\n\nInstall the latest version of Go by following [the docs on their website](https://golang.org/doc/install).\n\n### Clone the Lotus repository\n\n```sh\ngit clone https://github.com/filecoin-project/lotus.git\ncd lotus/\n```\n\n### Build the Lotus binaries from source and install\n\n```sh\nmake clean && make all\nsudo make install\n```\n\nAfter installing Lotus, you can run the `lotus` command directly from your CLI to see usage documentation. Next, you can join the [Lotus Testnet](https://docs.lotu.sh/en+join-testnet).\n\n### Interopnet\n\nIf you seek a smaller network to test, you can join the `interopnet`. Please note that this network is meant for developers - it resets much more often, and is much smaller. To join this network, checkout the branch `interopnet` instead of `master` before building and installing;\n```\ngit checkout interopnet\n```\n\nPlease also note that this documentation (if viewed on the website) might not be up to date with the interopnet. For the latest documentation on the interopnet branch, see the [Lotus Documentation Interopnet Branch on GitHub](https://github.com/filecoin-project/lotus/tree/interopnet/documentation/en)\n"},{"title":"Fedora Installation","slug":"en+install-lotus-fedora","github":"en/install-lotus-fedora.md","value":"# Fedora Instructions\n\n> tested on 30\n\n**NOTE:** If you have an AMD GPU the opencl instructions may be incorrect...\n\nThese steps will install the following dependencies:\n\n- go (1.14 or higher)\n- gcc (7.4.0 or higher)\n- git (version 2 or higher)\n- bzr (some go dependency needs this)\n- jq\n- pkg-config\n- rustup (proofs build)\n- llvm (proofs build)\n- clang (proofs build)\n\nRun\n\n```sh\n$ sudo dnf -y update\n$ sudo dnf -y install go gcc git bzr jq pkgconfig mesa-libOpenCL mesa-libOpenCL-devel opencl-headers ocl-icd ocl-icd-devel clang llvm\n$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\nClone\n\n```sh\ngit clone https://github.com/filecoin-project/lotus.git\ncd lotus/\n```\n\nInstall\n\n```sh\n$ make clean && make all\n$ sudo make install\n```\n\nAfter installing Lotus, you can run the `lotus` command directly from your CLI to see usage documentation. Next, you can join the [Lotus TestNet](https://docs.lotu.sh/en+join-testnet).\n"},{"title":"MacOS Installation","slug":"en+install-lotus-macos","github":"en/install-lotus-macos.md","value":"# MacOS Instructions\n\n## Get XCode Command Line Tools\n\nTo check if you already have the XCode Command Line Tools installed via the CLI, run:\n\n```sh\nxcode-select -p\n```\n\nIf this command returns a path, you can move on to the next step. Otherwise, to install via the CLI, run:\n\n```sh\nxcode-select --install\n```\n\nTo update, run:\n\n```sh\nsudo rm -rf /Library/Developer/CommandLineTools\nxcode-select --install\n```\n\n## Get HomeBrew\n\nWe recommend that MacOS users use [HomeBrew](https://brew.sh) to install each the necessary packages.\n\nCheck if you have HomeBrew:\n\n```sh\nbrew -v\n```\n\nThis command returns a version number if you have HomeBrew installed and nothing otherwise.\n\nIn your terminal, enter this command to install Homebrew:\n\n```sh\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\nUse the command `brew install` to install the following packages:\n\n```sh\nbrew install go bzr jq pkg-config rustup\n```\n\nClone\n\n```sh\ngit clone https://github.com/filecoin-project/lotus.git\ncd lotus/\n```\n\nBuild\n\n```sh\nmake clean && make all\nsudo make install\n```\n\nAfter installing Lotus, you can run the `lotus` command directly from your CLI to see usage documentation. Next, you can join the [Lotus Testnet](https://docs.lotu.sh/en+join-testnet).\n"},{"title":"Updating Lotus","slug":"en+updating-lotus","github":"en/updating-lotus.md","value":"# Updating Lotus\n\nIf you installed Lotus on your machine, you can upgrade to the latest version by doing the following:\n\n```sh\n# get the latest\ngit pull origin master\n\n# clean and remake the binaries\nmake clean && make build\n\n# instal binaries in correct location\nmake install # or sudo make install if necessary\n```\n"},{"title":"Join Testnet","slug":"en+join-testnet","github":"en/join-testnet.md","value":"# Join Testnet\n\n## Introduction\n\nAnyone can set up a **Lotus Node** and connect to the **Lotus Testnet**. This is the best way to explore the current CLI and the **Filecoin Decentralized Storage Market**.\n\n## Note: Using the Lotus Node from China\n\nIf you are trying to use `lotus` from China. You should set this **environment variable** on your machine:\n\n```sh\nIPFS_GATEWAY=\"https://proof-parameters.s3.cn-south-1.jdcloud-oss.com/ipfs/\"\n```\n\n## Get started\n\nStart the **daemon** using the default configuration in `./build`:\n\n```sh\nlotus daemon\n```\n\nIn another terminal window, check your connection with peers:\n\n```sh\nlotus net peers | wc -l\n```\n\nIn order to connect to the network, you need to be connected to at least 1 peer. If youâ€™re seeing 0 peers, read our [troubleshooting notes](https://docs.lotu.sh/en+setup-troubleshooting).\n\nMake sure that you have a reasonable \"open files limit\" set on your machine, such as 10000. If you're seeing a lower value, such as 256 (default on macOS), read our [troubleshooting notes](https://docs.lotu.sh/en+setup-troubleshooting) on how to update it prior to starting the Lotus daemon.\n\n## Chain sync\n\nWhile the daemon is running, the next requirement is to sync the chain. Run the command below to view the chain sync progress. To see current chain height, visit the [network stats page](https://stats.testnet.filecoin.io/).\n\n```sh\nlotus sync wait\n```\n\n- This step will take anywhere between a few hours to a couple of days.\n- You will be able to perform **Lotus Testnet** operations after it is finished.\n\n## Create your first address\n\nInitialize a new wallet:\n\n```sh\nlotus wallet new\n```\n\nSometimes your operating system may limit file name length to under 150 characters. You need to use a file system that supports long filenames.\n\nHere is an example of the response:\n\n```sh\nt1aswwvjsae63tcrniz6x5ykvsuotlgkvlulnqpsi\n```\n\n- Visit the [faucet](https://faucet.testnet.filecoin.io) to add funds.\n- Paste the address you created.\n- Press the send button.\n\n## Check wallet address balance\n\nWallet balances in the Lotus Testnet are in **FIL**, the smallest denomination of FIL is an **attoFil**, where 1 attoFil = 10^-18 FIL.\n\n```sh\nlotus wallet balance <YOUR_NEW_ADDRESS>\n```\n\nYou will not see any attoFIL in your wallet if your **chain** is not fully synced.\n\n## Send FIL to another wallet\n\nTo send FIL to another wallet from your default account, use this command:\n\n```\nlotus send <target> <amount>\n```\n\n## Configure your node's connectivity\n\nTo effectively accept incoming storage & retrieval deals, your Lotus node needs to be accessible to other nodes on the network. To improve your connectivity, be sure to: \n\n- [Set the multiaddresses for you miner to listen on](https://docs.filecoin.io/mine/connectivity/#setting-multiaddresses)\n- [Maintain a healthy peer count](https://docs.filecoin.io/mine/connectivity/#checking-peer-count)\n- [Enable port forwarding](https://docs.filecoin.io/mine/connectivity/#port-forwarding)\n- [Configure your public IP address and port](https://docs.filecoin.io/mine/connectivity/#setting-a-public-ip-address)\n\n## Monitor the dashboard\n\nTo see the latest network activity, including **chain block height**, **block height**, **blocktime**, **total network power**, largest **block producer miner**, check out the [monitoring dashboard](https://stats.testnet.filecoin.io).\n"},{"title":"Use Lotus with systemd","slug":"en+install-systemd-services","github":"en/install-systemd-services.md","value":"# Use Lotus with systemd\n\nLotus is capable of running as a systemd service daemon. You can find installable service files for systemd in the [lotus repo scripts directory](https://github.com/filecoin-project/lotus/tree/master/scripts) as files with `.service` extension. In order to install these service files, you can copy these `.service` files to the default systemd service path.\n\n## Installing via `make`\n\nNOTE: Before using lotus and lotus-miner as systemd services, don't forget to `sudo make install` to ensure the binaries are accessible by the root user.\n\nIf your host uses the default systemd service path, it can be installed with `sudo make install-services`:\n\n```sh\n$ sudo make install-services\n```\n\n## Interacting with service logs\n\nLogs from the services can be reviewed using `journalctl`.\n\n### Follow logs from a specific service unit\n\n```sh\n$ sudo journalctl -u lotus-daemon -f\n```\n\n### View logs in reverse order\n\n```sh\n$ sudo journalctl -u lotus-miner -r\n```\n"},{"title":"Setup Troubleshooting","slug":"en+setup-troubleshooting","github":"en/setup-troubleshooting.md","value":"# Setup Troubleshooting\n\n## Config: Clearing data\n\nHere is a command that will delete your chain data, stored wallets, stored data and any miners you have set up:\n\n```sh\nrm -rf ~/.lotus ~/.lotusstorage\n```\n\nThis command usually resolves any issues with running `lotus` but it is not always required for updates. We will share information about when resetting your chain data and miners is required for an update in the future.\n\n## Error: Failed to connect bootstrap peer\n\n```sh\nWARN  peermgr peermgr/peermgr.go:131  failed to connect to bootstrap peer: failed to dial : all dials failed\n  * [/ip4/147.75.80.17/tcp/1347] failed to negotiate security protocol: connected to wrong peer\n```\n\n- Try running the build steps again and make sure that you have the latest code from GitHub.\n\n```sh\nERROR hello hello/hello.go:81 other peer has different genesis!\n```\n\n- Try deleting your file system's `~/.lotus` directory. Check that it exists with `ls ~/.lotus`.\n\n```sh\n- repo is already locked\n```\n\n- You already have another lotus daemon running.\n\n## Config: Open files limit\n\nOn most systems you can check the open files limit with:\n\n```sh\nulimit -n\n```\n\nYou can also modify this number by using the `ulimit` command. It gives you the ability to control the resources available for the shell or process started by it. If the number is below 10000, you can change it with the following command prior to starting the Lotus daemon:\n\n```sh\nulimit -n 10000\n```\n"}]},{"title":"Architecture","slug":"en+arch","github":"en/architecture.md","value":"# Lotus\n\nLotus is an implementation of the [Filecoin Distributed Storage Network](https://filecoin.io/).\nA Lotus node syncs blockchains that follow the\nFilecoin protocol, validating the blocks and state transitions.\nThe specification for the Filecoin protocol can be found [here](https://filecoin-project.github.io/specs/).\n\nFor information on how to setup and operate a Lotus node,\nplease follow the instructions [here](https://lotu.sh/en+getting-started).\n\n# Components\n\nAt a high level, a Lotus node comprises the following components:\n\nFIXME: No mention of block production here, cross-reference with schomatis's miner doc\n- The Syncer, which manages the process of syncing the blockchain\n- The State Manager, which can compute the state at any given point in the chain\n- The Virtual Machine (VM), which executes messages\n- The Repository, where all data is stored\n- P2P stuff (FIXME missing libp2p listed under other PL dependencies)? allows hello, blocksync, retrieval, storage\n- API / CLI (FIXME missing, in scratchpad)\n- Other Filecoin dependencies (specs actors, proofs, storage, etc., FIXME missing)\n- Is the Builder worth its own component?\n- Other PL dependencies (IPFS, libp2p, IPLD? FIXME, missing)\n- External libraries used by Lotus and other deps (FIXME, missing)\n\n# Preliminaries\n\nWe discuss some key Filecoin concepts here, aiming to explain them by contrasting them with analogous concepts\nin other well-known blockchains like Ethereum. We only provide brief descriptions here; elaboration\ncan be found in the [spec](https://filecoin-project.github.io/specs/).\n\n### Tipsets\n\nUnlike in Ethereum, a block can have multiple parents in Filecoin. We thus refer to the parent set of a block,\ninstead of a single parent.\nA [tipset](https://filecoin-project.github.io/specs/#systems__filecoin_blockchain__struct__tipset)\nis any set of blocks that share the same parent set.\n\nThere is no concept of \"block difficulty\" in Filecoin. Instead,\nthe weight of a tipset is simply the number of blocks in the chain that ends in that tipset. Note that a longer chain\ncan have less weight than a shorter chain with more blocks per tipset.\n\nWe also allow for \"null\" tipsets, which include zero blocks. This allows miners to \"skip\" a round, and build on top\nof an imaginary empty tipset if they want to.\n\nWe call the heaviest tipset in a chain the \"head\" of the chain.\n\n### Actors and Messages\n\nAn [Actor](https://filecoin-project.github.io/specs/#systems__filecoin_vm__actor)\n is analogous to a smart contract in Ethereum. Filecoin does not allow users to define their own\nactors, but comes with several [builtin actors](https://github.com/filecoin-project/specs-actors),\nwhich can be thought of as pre-compiled contracts.\n\nA [Message](https://filecoin-project.github.io/specs/#systems__filecoin_vm__message)\nis analogous to transactions in Ethereum.\n\n# Sync\n\nSync refers to the process by which a Lotus node synchronizes to the heaviest chain being advertised by its peers.\nAt a high-level, Lotus syncs in a manner similar to most other blockchains; a Lotus node listens to the various\nchains its peers claim to be at, picks the heaviest one, requests the blocks in the chosen chain,\nand validates each block in that chain, running all state transitions along the way.\n\nThe majority of the sync functionality happens in the [`Syncer`](https://github.com/filecoin-project/lotus/blob/master/chain/sync.go),\ninternally managed by a [`SyncManager`](https://github.com/filecoin-project/lotus/blob/master/chain/sync_manager.go).\n\nWe now discuss the various stages of the sync process.\n\n## Sync setup\n\nWhen a Lotus node connects to a new peer, we exchange the head of our chain\nwith the new peer through [the `hello` protocol](https://github.com/filecoin-project/lotus/blob/master/node/hello/hello.go).\nIf the peer's head is heavier than ours, we try to sync to it. Note\nthat we do NOT update our chain head at this stage.\n\n## Fetching and Persisting Block Headers\n\nNote: The API refers to these stages as `StageHeaders` and `StagePersistHeaders`.\n\nWe proceed in the sync process by requesting block headers from the peer,\nmoving back from their head, until we reach a tipset that we have in common\n(such a common tipset must exist, thought it may simply be the genesis block).\nThe functionality can be found in `Syncer::collectHeaders()`.\n\nIf the common tipset is our head, we treat the sync as a \"fast-forward\", else we must\ndrop part of our chain to connect to the peer's head (referred to as \"forking\").\n\nFIXME: This next para might be best replaced with a link to the validation doc\nSome of the possible causes of failure in this stage include:\n\n- The chain is linked to a block that we have previously marked as bad,\nand stored in a [`BadBlockCache`](https://github.com/filecoin-project/lotus/blob/master/chain/badtscache.go).\n- The beacon entries in a block are inconsistent (FIXME: more details about what is validated here wouldn't be bad).\n- Switching to this new chain would involve a chain reorganization beyond the allowed threshold (SPECK-CHECK).\n\n## Fetching and Validating Blocks\n\nNote: The API refers to this stage as `StageMessages`.\n\nHaving acquired the headers and found a common tipset, we then move forward, requesting the full blocks, including the messages.\n\nFor each block, we  first confirm the syntactic validity of the block (SPECK-CHECK),\nwhich includes the syntactic validity of messages included\nin the block.\nWe then apply the messages, running all the state transitions, and compare the state root we calculate with the provided state root.\n\n\nFIXME: This next para might be best replaced with a link to the validation doc\nSome of the possible causes of failure in this stage include:\n\n- a block is syntactically invalid (including potentially containing syntactically invalid messages)\n- the computed state root after applying the block doesn't match the block's state root\n- FIXME: Check what's covered by syntactic validity, and add anything important that isn't (like proof validity, future checks, etc.)\n\nThe core functionality can be found in `Syncer::ValidateTipset()`, with `Syncer::checkBlockMessages()` performing\nsyntactic validation of messages.\n\n## Setting the head\n\nNote: The API refers to this stage as `StageSyncComplete`.\n\nIf all validations pass we will now set that head as our heaviest tipset in\n[`ChainStore`](https://github.com/filecoin-project/lotus/blob/master/chain/store/store.go).\nWe already have the full state, since we calculated\nit during the sync process.\n\nFIXME (aayush) I don't fuilly understand the next 2 paragraphs, but it seems important. Confirm and polish.\nRelevant issue in IPFS: https://github.com/ipfs/ipfs-docs/issues/264\n\nIt is important to note at this point that similar to the IPFS architecture of addressing by content and not by location/address (FIXME: check and link to IPFS docs) the \"actual\" chain stored in the node repo is *relative* to which CID we look for. We always have stored a series of Filecoin blocks pointing to other blocks, each a potential chain in itself by following its parent's reference, and its parent's parent, and so on up to the genesis block. (FIXME: We need a diagram here, one of the Filecoin blog entries might have something similar to what we are describing here.) It only depends on *where* (location) do we start to look for. The *only* address/location reference we hold of the chain, a relative reference, is the `heaviest` pointer. This is reflected by the fact that we don't store it in the `Blockstore` by a fixed, *absolute*, CID that reflects its contents, as this will change each time we sync to a new head (FIXME: link to the immutability IPFS doc that I need to write).\n\nFIXME: Create a further reading appendix, move this next para to it, along with other\nextraneous content\nThis is one of the few items we store in `Datastore` by key, location, allowing its contents to change on every sync. This is reflected in the `(*ChainStore) writeHead()` function (called by `takeHeaviestTipSet()` above) where we reference the pointer by the explicit `chainHeadKey` address (the string `\"head\"`, not a hash embedded in a CID), and similarly in `(*ChainStore).Load()` when we start the node and create the `ChainStore`. Compare this to a Filecoin block or message which are immutable, stored in the `Blockstore` by CID, once created they never change.\n\n## Keeping up with the chain\n\nA Lotus node also listens for new blocks broadcast by its peers over the `gossipsub` channel (see FIXME for more).\nIf we have validated such a block's parent tipset, and adding it to our tipset at its height would lead to a heavier\nhead, then we validate and add this block. The validation described is identical to that invoked during the sync\nprocess (indeed, it's the same codepath).\n\n# State\n\nIn Filecoin, the chain state at any given point is  a collection of data stored under a root CID\nencapsulated in the [`StateTree`](https://github.com/filecoin-project/lotus/blob/master/chain/state/statetree.go),\nand accessed through the\n[`StateManager`](https://github.com/filecoin-project/lotus/blob/master/chain/stmgr/stmgr.go).\nThe state at the chain's head is thus easily tracked and updated in a state root CID.\n(FIXME: Talk about CIDs somewhere,  we might want to explain some of the modify/flush/update-root mechanism here.))\n\n## Calculating a Tipset State\n\nRecall that a tipset is a set of blocks that have identical parents (that is, that are built on top of the same tipset).\nThe genesis tipset comprises the genesis block(s), and has some state corresponding to it.\n\nThe methods `TipSetState()` and `computeTipSetState()` in\n[`StateManager`](https://github.com/filecoin-project/lotus/blob/master/chain/stmgr/stmgr.go)\n are responsible for computing\nthe state that results from applying a tipset. This involves applying all the messages included\nin the tipset, and performing implicit operations like awarding block rewards.\n\nAny valid block built on top of a tipset `ts` should have its Parent State Root equal to the result of\ncalculating the tipset state of `ts`. Note that this means that all blocks in a tipset must have the same Parent\nState Root (which is to be expected, since they have the same parent tipset)\n\n### Preparing to apply a tipset\n\nWhen `StateManager::computeTipsetState()` is called with a tipset, `ts`,\nit retrieves the parent state root of the blocks in `ts`. It also creates a list of `BlockMessages`, which wraps the BLS\nand SecP messages in a block along with the miner that produced the block.\n\nControl then flows to `StateManager::ApplyBlocks()`, which builds a VM to apply the messages given to it. The VM\nis initialized with the parent state root of the blocks in `ts`. We apply the blocks in `ts` in order (see FIXME for\nordering of blocks in a tipset).\n\n### Applying a block\n\nFor each block, we prepare to apply the ordered messages (first BLS, then SecP). Before applying a message, we check if\nwe have already applied a message with that CID within the scope of this method. If so, we simply skip that message;\nthis is how duplicate messages included in the same tipset are skipped (with only the miner of the \"first\" block to\ninclude the message getting the reward). For the actual process of message application, see FIXME (need an\ninternal link here), for now we\nsimply assume that the outcome of the VM applying a message is either an error, or a\n[`MessageReceipt`](https://github.com/filecoin-project/lotus/blob/master/chain/types/message_receipt.go)\n and some\nother information.\n\nWe treat an error from the VM as a showstopper; there is no recovery, and no meaningful state can be computed for `ts`.\nGiven a successful receipt, we add the rewards and penalties to what the miner has earned so far. Once all the messages\nincluded in a block have been applied (or skipped if they're a duplicate), we use an implicit message to call\nthe Reward Actor. This awards the miner their reward for having won a block, and also awards / penalizes them based\non the message rewards and penalties we tracked.\n\nWe then proceed to apply the next block in `ts`, using the same VM. This means that the state changes that result\nfrom applying a message are visible when applying all subsequent messages, even if they are included in a different block.\n\n### Finishing up\n\nHaving applied all the blocks, we send one more implicit message, to the Cron Actor, which handles operations that\nmust be performed at the end of every epoch (see FIXME for more). The resulting state after calling the Cron Actor\nis the computed state of the tipset.\n\n# Virtual Machine\n\nThe Virtual Machine (VM) is responsible for executing messages.\nThe [Lotus Virtual Machine](https://github.com/filecoin-project/lotus/blob/master/chain/vm/vm.go)\ninvokes the appropriate methods in the builtin actors, and provides\na [`Runtime`](https://github.com/filecoin-project/specs-actors/blob/master/actors/runtime/runtime.go)\ninterface to the [builtin actors](https://github.com/filecoin-project/specs-actors)\nthat exposes their state, allows them to take certain actions, and meters\ntheir gas usage. The VM also performs balance transfers, creates new account actors as needed, and tracks the gas reward,\npenalty, return value, and exit code.\n\n## Applying a Message\n\nThe primary entrypoint of the VM is the `ApplyMessage()` method. This method should not return an error\nunless something goes unrecoverably wrong.\n\nThe first thing this method does is assess if the message provided meets any of the penalty criteria.\nIf so, a penalty is issued, and the method returns. Next, the entire gas cost of the message is transferred to\na temporary gas holder account. It is from this gas holder that gas will be deducted; if it runs out of gas, the message\nfails. Any unused gas in this holder will be refunded to the message's sender at the end of message execution.\n\nThe VM then increments the sender's nonce, takes a snapshot of the state, and invokes `VM::send()`.\n\nThe `send()` method creates a [`Runtime`](https://github.com/filecoin-project/lotus/blob/master/chain/vm/runtime.go)\n for the subsequent message execution.\nIt then transfers the message's value to the recipient, creating a new account actor if needed.\n\n### Method Invocation\n\nWe use reflection to translate a Filecoin message for the VM to an actual Go function, relying on the VM's\n[`invoker`](https://github.com/filecoin-project/lotus/blob/master/chain/vm/invoker.go) structure.\nEach actor has its own set of codes defined in `specs-actors/actors/builtin/methods.go`.\nThe `invoker` structure maps the builtin actors' CIDs\n to a list of `invokeFunc` (one per exported method), which each take the `Runtime` (for state manipulation)\n and the serialized input parameters.\n\nFIXME (aayush) Polish this next para.\n\nThe basic layout (without reflection details) of `(*invoker).transform()` is as follows. From each actor registered in `NewInvoker()` we take its `Exports()` methods converting them to `invokeFunc`s. The actual method is wrapped in another function that takes care of decoding the serialized parameters and the runtime, this function is passed to `shimCall()` that will encapsulate the actors code being run inside a `defer` function to `recover()` from panics (we fail in the actors code with panics to unwrap the stack). The return values will then be (CBOR) marshaled and returned to the VM.\n\n### Returning from the VM\n\nOnce method invocation is complete (including any subcalls), we return to `ApplyMessage()`, which receives\nthe serialized response and the [`ActorError`](https://github.com/filecoin-project/lotus/blob/master/chain/actors/aerrors/error.go).\nThe sender will be charged the appropriate amount of gas for the returned response, which gets put into the\n[`MessageReceipt`](https://github.com/filecoin-project/lotus/blob/master/chain/types/message_receipt.go).\n\nThe method then refunds any unused gas to the sender, sets up the gas reward for the miner, and\nwraps all of this into an `ApplyRet`, which is returned.\n\n# Building a Lotus node\n\nWhen we launch a Lotus node with the command `./lotus daemon`\n(see [here](https://github.com/filecoin-project/lotus/blob/master/cmd/lotus/daemon.go) for more),\nthe node is created through [dependency injection](https://godoc.org/go.uber.org/fx).\nThis relies on reflection, which makes some of the references hard to follow.\nThe node sets up all of the subsystems it needs to run, such as the repository, the network connections, thechain sync\nservice, etc.\nThis setup is orchestrated through calls to the `node.Override` function.\nThe structure of each call indicates the type of component it will set up\n(many defined in [`node/modules/dtypes/`](https://github.com/filecoin-project/lotus/tree/master/node/modules/dtypes)),\nand the function that will provide it.\nThe dependency is implicit in the argument of the provider function.\n\nAs an example, consider the `modules.ChainStore()` function that provides the\n[`ChainStore`](https://github.com/filecoin-project/lotus/blob/master/chain/store/store.go) structure.\nIt takes as one of its parameters the [`ChainBlockstore`](https://github.com/filecoin-project/lotus/blob/master/node/modules/dtypes/storage.go)\ntype, which becomes one of its dependencies.\nFor the node to be built successfully the `ChainBlockstore` will need to be provided before `ChainStore`, a requirement\nthat is made explicit in another `Override()` call that sets the provider of that type as the `ChainBlockstore()` function.\n\n## The Repository\n\nThe repo is the directory where all of a node's information is stored. The node is entirely defined by its repo, which\nmakes it easy to port to another location. This one-to-one relationship means we can speak\nof the node as the repo it is associated with, instead of the daemon process that runs from that repo.\n\nOnly one daemon can run be running with an associated repo at a time.\nA process signals that it is running a node associated with a particular repo, by creating and acquiring\na `repo.lock`.\n\n```sh\nlsof ~/.lotus/repo.lock\n# COMMAND   PID\n# lotus   52356\n```\nTrying to launch a second daemon hooked to the same repo leads to a `repo is already locked (lotus daemon already running)`\nerror.\n\nThe `node.Repo()` function (`node/builder.go`) contains most of the dependencies (specified as `Override()` calls)\nneeded to properly set up the node's repo. We list the most salient ones here.\n\n### Datastore\n\n`Datastore` and `ChainBlockstore`: Data related to the node state is saved in the repo's `Datastore`,\nan IPFS interface defined [here](https://github.com/ipfs/go-datastore/blob/master/datastore.go).\nLotus creates this interface from a [Badger DB](https://github.com/dgraph-io/badger) in\n [`FsRepo`](https://github.com/filecoin-project/lotus/blob/master/node/repo/fsrepo.go).\nEvery piece of data is fundamentally a key-value pair in the `datastore` directory of the repo.\nThere are several abstractions laid on top of it that appear through the code depending on *how* we access it,\nbut it is important to remember that we're always accessing it from the same place.\n\nFIXME: Maybe mention the `Batching` interface as the developer will stumble upon it before reaching the `Datastore` one.\n\n#### Blocks\n\nFIXME: IPFS blocks vs Filecoin blocks ideally happens before this / here\n\nThe [`Blockstore` interface](`github.com/ipfs/go-ipfs-blockstore/blockstore.go`) structures the key-value pair\ninto the CID format for the key and the [`Block` interface](`github.com/ipfs/go-block-format/blocks.go`) for the value.\nThe `Block` value is just a raw string of bytes addressed by its hash, which is included in the CID key.\n\n`ChainBlockstore` creates a `Blockstore` in the repo under the `/blocks` namespace.\nEvery key stored there will have the `blocks` prefix so that it does not collide with other stores that use the same repo.\n\nFIXME: Link to IPFS documentation about DAG, CID, and related, especially we need a diagram that shows how do we wrap each datastore inside the next layer (datastore, batching, block store, gc, etc).\n\n#### Metadata\n\n`modules.Datastore()` creates a `dtypes.MetadataDS`, which is an alias for the basic `Datastore` interface.\nMetadata is stored here under the `/metadata` prefix.\n(FIXME: Explain *what* is metadata in contrast with the block store, namely we store the pointer to the heaviest chain, we might just link to that unwritten section here later.)\n\nFIXME: Explain the key store related calls (maybe remove, per Schomatis)\n\n### LockedRepo\n\n`LockedRepo()`: This method doesn't create or initialize any new structures, but rather registers an\n `OnStop` [hook](https://godoc.org/go.uber.org/fx/internal/lifecycle#Hook)\n that will close the locked repository associated with it on shutdown.\n\n\n### Repo types / Node types\n\nFIXME: This section needs to be clarified / corrected...I don't fully understand the config differences (what do they have in common, if anything?)\n\nAt the end of the `Repo()` function we see two mutually exclusive configuration calls based on the `RepoType` (`node/repo/fsrepo.go`).\n```Go\n\t\t\tApplyIf(isType(repo.FullNode), ConfigFullNode(c)),\n\t\t\tApplyIf(isType(repo.StorageMiner), ConfigStorageMiner(c)),\n```\nAs we said, the repo fully identifies the node so a repo type is also a *node* type, in this case a full node or a storage miner. (FIXME: What is the difference between the two, does *full* imply miner?) In this case the `daemon` command will create a `FullNode`, this is specified in the command logic itself in `main.DaemonCmd()`, the `FsRepo` created (and passed to `node.Repo()`) will be initiated with that type (see `(*FsRepo).Init(t RepoType)`).\n\n## Online\n\nFIXME: Much of this might need to be subsumed into the p2p section\n\nThe `node.Online()` configuration function (`node/builder.go`) initializes components that involve connecting to,\nor interacting with, the Filecoin network. These connections are managed through the libp2p stack (FIXME link to this section when it exists).\nWe discuss some of the components found in the full node type (that is, included in the `ApplyIf(isType(repo.FullNode),` call).\n\n#### Chainstore\n\n`modules.ChainStore()` creates the [`store.ChainStore`](https://github.com/filecoin-project/lotus/blob/master/chain/store/store.go))\nthat wraps the stores\n previously instantiated in `Repo()`. It is the main point of entry for the node to all chain-related data\n (FIXME: this is incorrect, we sometimes access its underlying block store directly, and probably shouldn't).\n It also holds the crucial `heaviest` pointer, which indicates the current head of the chain.\n\n #### ChainExchange and ChainBlockservice\n`ChainExchange()` and `ChainBlockservice()` establish a BitSwap connection (FIXME libp2p link)\nto exchange chain information in the form of `blocks.Block`s stored in the repo. (See sync section for more details, the Filecoin blocks and messages are backed by these raw IPFS blocks that together form the different structures that define the state of the current/heaviest chain.)\n\n#### Incoming handlers\n`HandleIncomingBlocks()` and `HandleIncomingMessages()` start the services in charge of processing new Filecoin blocks\nand messages from the network (see `<undefined>` for more information about the topics the node is subscribed to, FIXME: should that be part of the libp2p section or should we expand on gossipsub separately?).\n\n#### Hello\n`RunHello()`: starts the services to both send (`(*Service).SayHello()`) and receive (`(*Service).HandleStream()`, `node/hello/hello.go`)\n`hello` messages. When nodes establish a new connection with each other, they exchange these messages\nto share chain-related information (namely their genesis block and their heaviest tipset).\n\n#### Syncer\n`NewSyncer()` creates the `Syncer` structure and starts the services related to the chain sync process (FIXME link).\n\n### Ordering the dependencies\n\nWe can establish the dependency relations by looking at the parameters that each function needs and by understanding\nthe architecture of the node and how the different components relate to each other (the chief purpose of this document).\n\nAs an example, the sync mechanism depends on the node being able to exchange different IPFS blocks with the network,\nso as to be able to request the \"missing pieces\" needed to construct the chain. This dependency is reflected by `NewSyncer()`\nhaving a `blocksync.BlockSync` parameter, which in turn depends on `ChainBlockservice()` and `ChainExchange()`.\nThe chain exchange service further depends on the chain store to save and retrieve chain data, which is reflected\nin `ChainExchange()` having `ChainGCBlockstore` as a parameter (which is just a wrapper around `ChainBlockstore` capable\n of garbage collection).\n\nThis block store is the same store underlying the chain store, which is an indirect dependency of `NewSyncer()` (through the `StateManager`).\n(FIXME: This last line is flaky, we need to resolve the hierarchy better, we sometimes refer to the chain store and sometimes to its underlying block store. We need a diagram to visualize all the different components just mentioned otherwise it is too hard to follow. We probably even need to skip some of the connections mentioned.)\n","posts":[]},{"title":"Storage Mining","slug":"en+mining","github":"en/mining.md","value":"# Storage Mining\n\nHere are instructions to learn how to perform storage mining. For hardware specifications please read [this](https://docs.lotu.sh/en+hardware-mining).\n\nIt is useful to [join the Testnet](https://docs.lotu.sh/en+join-testnet) prior to attempting storage mining for the first time.\n\n## Note: Using the Lotus Storage Miner from China\n\nIf you are trying to use `lotus-storage-miner` from China. You should set this **environment variable** on your machine.\n\n```sh\nIPFS_GATEWAY=\"https://proof-parameters.s3.cn-south-1.jdcloud-oss.com/ipfs/\"\n```\n\n## Get started\n\nPlease ensure that at least one **BLS address** (starts with `t3`) in your wallet exists with the following command:\n\n```sh\nlotus wallet list\n```\n\nIf you do not have a bls address, create a new bls wallet:\n\n```sh\nlotus wallet new bls\n```\n\nWith your wallet address:\n\n- Visit the [faucet](https://faucet.testnet.filecoin.io)\n- Click \"Create Miner\"\n- DO NOT REFRESH THE PAGE. THIS OPERATION CAN TAKE SOME TIME.\n\nThe task will be complete when you see:\n\n```sh\nNew storage miners address is: <YOUR_NEW_MINING_ADDRESS>\n```\n\n## Initialize the storage miner\n\nIn a CLI window, use the following command to start your miner:\n\n```sh\nlotus-storage-miner init --actor=ACTOR_VALUE_RECEIVED --owner=OWNER_VALUE_RECEIVED\n```\n\nExample\n\n```sh\nlotus-storage-miner init --actor=t01424 --owner=t3spmep2xxsl33o4gxk7yjxcobyohzgj3vejzerug25iinbznpzob6a6kexcbeix73th6vjtzfq7boakfdtd6a\n```\n\nYou will have to wait some time for this operation to complete.\n\n## Mining\n\nTo mine:\n\n```sh\nlotus-storage-miner run\n```\n\nIf you are downloading **Filecoin Proof Parameters**, the download can take some time.\n\nGet information about your miner:\n\n```sh\nlotus-storage-miner info\n# example: miner id `t0111`\n```\n\n**Seal** random data to start producing **PoSts**:\n\n```sh\nlotus-storage-miner sectors pledge\n```\n\n- Warning: On Linux configurations, this command will write data to `$TMPDIR` which is not usually the largest partition. You should point the value to a larger partition if possible.\n\nGet **miner power** and **sector usage**:\n\n```sh\nlotus state power\n# returns total power\n\nlotus state power <miner>\n\nlotus state sectors <miner>\n```\n\n## Performance tuning\n\n### `FIL_PROOFS_MAXIMIZE_CACHING=1` Environment variable\n\nThis env var can be used with `lotus-storage-miner`, `lotus-seal-worker`, and `lotus-bench` to make the precommit1 step faster at the cost of some memory use (1x sector size)\n\n### `FIL_PROOFS_USE_GPU_COLUMN_BUILDER=1` Environment variable\n\nThis env var can be used with `lotus-storage-miner`, `lotus-seal-worker`, and `lotus-bench` to enable experimental precommit2 GPU acceleration\n","posts":[{"title":"Lotus Seal Worker","slug":"en+lotus-seal-worker","github":"en/mining-lotus-seal-worker.md","value":"# Lotus Seal Worker\n\nThe **Lotus Seal Worker** is an extra process that can offload heavy processing tasks from your **Lotus Storage Miner**. The sealing process automatically runs in the **Lotus Storage Miner** process, but you can use the Seal Worker on another machine communicating over a fast network to free up resources on the machine running the mining process.\n\n## Note: Using the Lotus Seal Worker from China\n\nIf you are trying to use `lotus-seal-worker` from China. You should set this **environment variable** on your machine:\n\n```sh\nIPFS_GATEWAY=\"https://proof-parameters.s3.cn-south-1.jdcloud-oss.com/ipfs/\"\n```\n\n## Get Started\n\nMake sure that the `lotus-seal-worker` is compiled and installed by running:\n\n```sh\nmake lotus-seal-worker\n```\n\n## Setting up the Storage Miner\n\nFirst, you will need to ensure your `lotus-storage-miner`'s API is accessible over the network.\n\nTo do this, open up `~/.lotusstorage/config.toml` (Or if you manually set `LOTUS_STORAGE_PATH`, look under that directory) and look for the API field.\n\nDefault config:\n\n```toml\n[API]\nListenAddress = \"/ip4/127.0.0.1/tcp/2345/http\"\nRemoteListenAddress = \"127.0.0.1:2345\"\n```\n\nTo make your node accessible over the local area network, you will need to determine your machines IP on the LAN, and change the `127.0.0.1` in the file to that address.\n\nA more permissive and less secure option is to change it to `0.0.0.0`. This will allow anyone who can connect to your computer on that port to access the [API](https://docs.lotu.sh/en+api). They will still need an auth token.\n\n`RemoteListenAddress` must be set to an address which other nodes on your network will be able to reach.\n\nNext, you will need to [create an authentication token](https://docs.lotu.sh/en+api-scripting-support#generate-a-jwt-46). All Lotus APIs require authentication tokens to ensure your processes are as secure against attackers attempting to make unauthenticated requests to them.\n\n### Connect the Lotus Seal Worker\n\nOn the machine that will run `lotus-seal-worker`, set the `STORAGE_API_INFO` environment variable to `TOKEN:STORAGE_NODE_MULTIADDR`. Where `TOKEN` is the token we created above, and `STORAGE_NODE_MULTIADDR` is the `multiaddr` of the **Lotus Storage Miner** API that was set in `config.toml`.\n\nOnce this is set, run:\n\n```sh\nlotus-seal-worker run --address 192.168.2.10:2345\n```\n\nReplace `192.168.2.10:2345` with the proper IP and port.\n\nTo check that the **Lotus Seal Worker** is connected to your **Lotus Storage Miner**, run `lotus-storage-miner workers list` and check that the remote worker count has increased.\n\n```sh\nwhy@computer ~/lotus> lotus-storage-miner workers list\nWorker 0, host computer\n        CPU:  [                                                                ] 0 core(s) in use\n        RAM:  [||||||||||||||||||                                              ] 28% 18.1 GiB/62.7 GiB\n        VMEM: [||||||||||||||||||                                              ] 28% 18.1 GiB/62.7 GiB\n        GPU: GeForce RTX 2080, not used\n\nWorker 1, host othercomputer\n        CPU:  [                                                                ] 0 core(s) in use\n        RAM:  [||||||||||||||                                                  ] 23% 14 GiB/62.7 GiB\n        VMEM: [||||||||||||||                                                  ] 23% 14 GiB/62.7 GiB\n        GPU: GeForce RTX 2080, not used\n```\n\n### Running locally for manually managing process priority\n\nYou can also run the **Lotus Seal Worker** on the same machine as your **Lotus Storage Miner**, so you can manually manage the process priority.\nTo do so you have to first __disable all seal task types__ in the miner config. This is important to prevent conflicts between the two processes.\n\nYou can then run the storage miner on your local-loopback interface; \n\n```sh\nlotus-seal-worker run --address 127.0.0.1:2345\n```"},{"title":"Static Ports","slug":"en+setting-a-static-port","github":"en/setting-a-static-port.md","value":"# Static Ports\n\nDepending on how your network is set up, you may need to set a static port to successfully connect to peers to perform storage deals with your **Lotus Storage Miner**.\n\n## Setup\n\nTo change the random **swarm port**, you may edit the `config.toml` file located under `$LOTUS_STORAGE_PATH`. The default location of this file is `$HOME/.lotusstorage`.\n\nTo change the port to `1347`:\n\n```sh\n[Libp2p]\n  ListenAddresses = [\"/ip4/0.0.0.0/tcp/1347\", \"/ip6/::/tcp/1347\"]\n```\n\nAfter changing the port value, restart your **daemon**.\n\n## Announce Addresses\n\nIf the **swarm port** is port-forwarded from another address, it is possible to control what addresses\nare announced to the network.\n\n```sh\n[Libp2p]\n  AnnounceAddresses = [\"/ip4/<public-ip>/tcp/1347\"]\n```\n\nIf non-empty, this array specifies the swarm addresses to announce to the network. If empty, the daemon will announce inferred swarm addresses.\n\nSimilarly, it is possible to set `NoAnnounceAddresses` with an array of addresses to not announce to the network.\n\n## Ubuntu's Uncomplicated Firewall\n\nOpen firewall manually:\n\n```sh\nufw allow 1347/tcp\n```\n\nOr open and modify the profile located at `/etc/ufw/applications.d/lotus-daemon`:\n\n```sh\n[Lotus Daemon]\ntitle=Lotus Daemon\ndescription=Lotus Daemon firewall rules\nports=1347/tcp\n```\n\nThen run these commands:\n\n```sh\nufw update lotus-daemon\nufw allow lotus-daemon\n```\n"},{"title":"Mining Troubleshooting","slug":"en+mining-troubleshooting","github":"en/mining-troubleshooting.md","value":"# Mining Troubleshooting\n\n## Config: Filecoin Proof Parameters directory\n\nIf you want to put the **Filecoin Proof Parameters** in a different directory, use the following environment variable:\n\n```sh\nFIL_PROOFS_PARAMETER_CACHE\n```\n\n## Error: Can't acquire bellman.lock\n\nThe **Bellman** lockfile is created to lock a GPU for a process. This bug can occur when this file isn't properly cleaned up:\n\n```sh\nmining block failed: computing election proof: github.com/filecoin-project/lotus/miner.(*Miner).mineOne\n```\n\nThis bug occurs when the storage miner can't acquire the `bellman.lock`. To fix it you need to stop the `lotus-storage-miner` and remove `/tmp/bellman.lock`.\n\n## Error: Failed to get api endpoint\n\n```sh\nlotus-storage-miner info\n# WARN  main  lotus-storage-miner/main.go:73  failed to get api endpoint: (/Users/myrmidon/.lotusstorage) %!w(*errors.errorString=&{API not running (no endpoint)}):\n```\n\nIf you see this, that means your **Lotus Storage Miner** isn't ready yet. You need to finish [syncing the chain](https://docs.lotu.sh/en+join-testnet).\n\n## Error: Your computer may not be fast enough\n\n```sh\nCAUTION: block production took longer than the block delay. Your computer may not be fast enough to keep up\n```\n\nIf you see this, that means your computer is too slow and your blocks are not included in the chain, and you will not receive any rewards.\n\n## Error: No space left on device\n\n```sh\nlotus-storage-miner sectors pledge\n# No space left on device (os error 28)\n```\n\nIf you see this, that means `pledge-sector` wrote too much data to `$TMPDIR` which by default is the root partition (This is common for Linux setups). Usually your root partition does not get the largest partition of storage so you will need to change the environment variable to something else.\n\n## Error: GPU unused\n\nIf you suspect that your GPU is not being used, first make sure it is properly configured as described in the [testing configuration page](hardware-mining.md). Once you've done that (and set the `BELLMAN_CUSTOM_GPU` as appropriate if necessary) you can verify your GPU is being used by running a quick lotus-bench benchmark.\n\nFirst, to watch GPU utilization run `nvtop` in one terminal, then in a separate terminal, run:\n\n```sh\nmake bench\n./bench sealing --sector-size=2KiB\n```\n\nThis process uses a fair amount of GPU, and generally takes ~4 minutes to complete. If you do not see any activity in nvtop from lotus during the entire process, it is likely something is misconfigured with your GPU.\n\n## Checking Sync Progress\n\nYou can use this command to check how far behind you are on syncing:\n\n```sh\ndate -d @$(./lotus chain getblock $(./lotus chain head) | jq .Timestamp)\n```\n"}]},{"title":"Storing Data","slug":"en+storing-data","github":"en/storing-data.md","value":"# Storing Data\n\n> There are recent bug reports with these instructions. If you happen to encounter any problems, please create a [GitHub issue](https://github.com/filecoin-project/lotus/issues/new) and a maintainer will address the problem as soon as they can.\n\nHere are instructions for how to store data on the **Lotus Testnet**.\n\n## Adding a file locally\n\nAdding a file locally allows you to make miner deals on the **Lotus Testnet**.\n\n```sh\nlotus client import ./your-example-file.txt\n```\n\nUpon success, this command will return a **Data CID**.\n\n## List your local files\n\nThe command to see a list of files by `CID`, `name`, `size` in bytes, and `status`:\n\n```sh\nlotus client local\n```\n\nAn example of the output:\n\n```sh\nbafkreierupr5ioxn4obwly4i2a5cd2rwxqi6kwmcyyylifxjsmos7hrgpe Development/sample-1.txt 2332 ok\nbafkreieuk7h4zs5alzpdyhlph4lxkefowvwdho3a3pml6j7dam5mipzaii Development/sample-2.txt 30618 ok\n```\n\n## Make a Miner Deal on Lotus Testnet\n\nGet a list of all miners that can store data:\n\n```sh\nlotus state list-miners\n```\n\nGet the requirements of a miner you wish to store data with:\n\n```sh\nlotus client query-ask <miner>\n```\n\nStore a **Data CID** with a miner:\n\n```sh\nlotus client deal <Data CID> <miner> <price> <duration>\n```\n\nCheck the status of a deal:\n\n```sh\nlotus client list-deals\n```\n\n- The `duration`, which represents how long the miner will keep your file hosted, is represented in blocks. Each block represents 25 seconds.\n\nUpon success, this command will return a **Deal CID**.\n\nThe storage miner will need to **seal** the file before it can be retrieved. If the **Lotus Storage Miner** is not running on a machine designed for sealing, the process will take a very long time.\n","posts":[{"title":"Storage Troubleshooting","slug":"en+storing-data-troubleshooting","github":"en/storing-data-troubleshooting.md","value":"# Storage Troubleshooting\n\n## Error: Routing: not found\n\n```sh\nWARN  main  lotus/main.go:72  routing: not found\n```\n\n- This miner is offline.\n\n## Error: Failed to start deal\n\n```sh\nWARN  main  lotus/main.go:72  failed to start deal: computing commP failed: generating CommP: Piece must be at least 127 bytes\n```\n\n- There is a minimum file size of 127 bytes.\n\n## Error: 0kb file response during retrieval\n\nIn order to retrieve a file, it must be sealed. Miners can check sealing progress with this command:\n\n```sh\nlotus-storage-miner sectors list\n```\n\nWhen sealing is complete, `pSet: NO` will become `pSet: YES`. From now on the **Data CID** is [retrievable](https://docs.lotu.sh/en+retrieving-data) from the **Lotus Storage Miner**.\n"},{"title":"Information for Miners","slug":"en+info-for-miners","github":"en/miner-deals.md","value":"# Information for Miners \n\nHere is how a miner can get set up to accept storage deals. The first step is\nto install a Lotus node and sync to the top of the chain.\n\n## Set up an ask\n\n```\nlotus-storage-miner set-price <price>\n```\n\nThis command will set up your miner to accept deal proposals that meet the input price.\nThe price is inputted in FIL per GiB per epoch, and the default is 0.0000000005. \n\n## Ensure you can be discovered\n\nClients need to be able to find you in order to make storage deals with you. \nWhile there isn't necessarily anything you need to do to become discoverable, here are some things you can\ntry to check that people can connect to you. \n\nTo start off, make sure you are connected to at least some peers, and your port is \nopen and working.\n\n### Connect to your own node\n\nIf you are in contact with someone else running Lotus, you can ask them to try connecting\nto your node. To do so, provide them your peer ID, which you can get by running `lotus net id` on\nyour node.\n\nThey can then try running `lotus net findpeer <peerID>` to get your address(es), and can then\nrun `lotus net connect <address>` to connect to you. If successful, your node will now\nappear on their peers list (run `lotus net peers` to check).\n\nYou can also check this by running a second instance of Lotus yourself.\n\n### Query your own ask\n\nA client should be able to find your ask by running `lotus client query-ask <minerID>`. If \nsomeone is not able to retrieve your ask by doing so, then there is an issue with your node."},{"title":"IPFS Integration","slug":"en+ipfs-client-integration","github":"en/storing-ipfs-integration.md","value":"# IPFS Integration\n\nLotus supports making deals with data stored in IPFS, without having to re-import it into lotus.\n\nTo enable this integration, you need to have an IPFS daemon running in the background.\nThen, open up `~/.lotus/config.toml` (or if you manually set `LOTUS_PATH`, look under that directory) \nand look for the Client field, and set `UseIpfs` to `true`.\n\n```toml\n[Client]\nUseIpfs = true\n```\n\nAfter restarting the lotus daemon, you should be able to make deals with data in your IPFS node:\n\n```sh\n$ ipfs add -r SomeData\nQmSomeData\n$ ./lotus client deal QmSomeData t01000 0.0000000001 80000\n```\n"}]},{"title":"Retrieving Data","slug":"en+retrieving-data","github":"en/retrieving-data.md","value":"# Retrieving Data\n\n> There are recent bug reports with these instructions. If you happen to encounter any problems, please create a [GitHub issue](https://github.com/filecoin-project/lotus/issues/new) and a maintainer will address the problem as soon as they can.\n\nHere are the operations you can perform after you have stored and sealed a **Data CID** with the **Lotus Storage Miner** in the network.\n\nIf you would like to learn how to store a **Data CID** on a miner, read the instructions [here](https://docs.lotu.sh/en+storing-data).\n\n## Find by Data CID\n\n```sh\nlotus client find <Data CID>\n# LOCAL\n# RETRIEVAL <miner>@<miner peerId>-<deal funds>-<size>\n```\n\n## Retrieve by Data CID\n\nAll fields are required.\n\n```sh\nlotus client retrieve <Data CID> <outfile>\n```\n\nIf the outfile does not exist it will be created in the Lotus repository directory.\n\nThis command will initiate a **retrieval deal** and write the data to your computer. This process may take 2 to 10 minutes.\n","posts":[]},{"title":"Command Line Interface","slug":"en+cli","github":"en/cli.md","value":"# Lotus Command Line Interface\n\nThe Command Line Interface (CLI) is a convenient way to interact with\na Lotus node. You can use the CLI to operate your node,\nget information about the blockchain,\nmanage your accounts and transfer funds,\ncreate storage deals, and much more! \n\nThe CLI is intended to be self-documenting, so when in doubt, simply add `--help`\nto whatever command you're trying to run! This will also display all of the \ninput parameters that can be provided to a command.\n\nWe highlight some of the commonly\nused features of the CLI below.\nAll CLI commands should be run from the home directory of the Lotus project.\n\n## Operating a Lotus node\n\n### Starting up a node\n\n```sh\nlotus daemon\n```\nThis command will start up your Lotus node, with its API port open at 1234. \nYou can pass `--api=<number>` to use a different port.\n\n### Checking your sync progress\n\n```sh\nlotus sync status\n```\nThis command will print your current tipset height under `Height`, and the target tipset height\nunder `Taregt`. \n\nYou can also run `lotus sync wait` to get constant updates on your sync progress.\n\n### Getting the head tipset\n\n```sh\nlotus chain head\n```\n\n### Control the logging level\n\n```sh\nlotus log set-level\n```\nThis command can be used to toggle the logging levels of the different\nsystems of a Lotus node. In decreasing order\nof logging detail, the levels are `debug`, `info`, `warn`, and `error`. \n\nAs an example,\nto set the `chain` and `blocksync` to log at the `debug` level, run \n`lotus log set-level --system chain --system blocksync debug`. \n\nTo see the various logging system, run `lotus log list`.\n\n### Find out what version of Lotus you're running\n\n```sh\nlotus version\n```\n\n## Managing your accounts\n\n### Listing accounts in your wallet\n\n```sh\nlotus wallet list\n``` \n\n### Creating a new account\n\n```sh\nlotus wallet new bls\n```\nThis command will create a new BLS account in your wallet; these\naddresses start with the prefix `t3`. Running `lotus wallet new secp256k1` \n(or just `lotus wallet new`) will create\na new Secp256k1 account, which begins with the prefix `t1`.\n\n### Getting an account's balance\n\n```sh\nlotus wallet balance <address>\n``` \n\n### Transferring funds \n\n```sh\nlotus send --source=<source address> <destination address> <amount>\n``` \nThis command will transfer `amount` (in attoFIL) from `source address` to `destination address`.\n\n### Importing an account into your wallet\n\n```sh\nlotus wallet import <path to private key>\n``` \nThis command will import an account whose private key is saved at the specified file.\n\n### Exporting an account from your wallet\n\n```sh\nlotus wallet export <address>\n``` \nThis command will print out the private key of the specified address\nif it is in your wallet. Always be careful with your private key!\n","posts":[]},{"title":"API","slug":"en+api","github":"en/api.md","value":"# API\n\nHere is an early overview of how to make API calls.\n\nImplementation details for the **JSON-RPC** package are [here](https://github.com/filecoin-project/go-jsonrpc).\n\n## Overview: How do you modify the config.toml to change the API endpoint?\n\nAPI requests are made against `127.0.0.1:1234` unless you modify `.lotus/config.toml`.\n\nOptions:\n\n- `http://[api:port]/rpc/v0` - HTTP endpoint\n- `ws://[api:port]/rpc/v0` - Websocket endpoint\n- `PUT http://[api:port]/rest/v0/import` - File import, it requires write permissions.\n\n## What methods can I use?\n\nFor now, you can look into different files to find methods available to you based on your needs:\n\n- [Both Lotus node + storage miner APIs](https://github.com/filecoin-project/lotus/blob/master/api/api_common.go)\n- [Lotus node API](https://github.com/filecoin-project/lotus/blob/master/api/api_full.go)\n- [Storage miner API](https://github.com/filecoin-project/lotus/blob/master/api/api_storage.go)\n\nThe necessary permissions for each are in [api/struct.go](https://github.com/filecoin-project/lotus/blob/master/api/struct.go).\n\n## How do I make an API request?\n\nTo demonstrate making an API request, we will take the method `ChainHead` from [api/api.go](https://github.com/filecoin-project/lotus/blob/master/api/api_full.go).\n\n```go\nChainHead(context.Context) (*types.TipSet, error)\n```\n\nAnd create a CURL command. In this command, `ChainHead` is included as `{ \"method\": \"Filecoin.ChainHead\" }`:\n\n```sh\ncurl -X POST \\\n     -H \"Content-Type: application/json\" \\\n     --data '{ \"jsonrpc\": \"2.0\", \"method\": \"Filecoin.ChainHead\", \"params\": [], \"id\": 3 }' \\\n     'http://127.0.0.1:1234/rpc/v0'\n```\n\nIf the request requires authorization, add an authorization header:\n\n```sh\ncurl -X POST \\\n     -H \"Content-Type: application/json\" \\\n     -H \"Authorization: Bearer $(cat ~/.lotusstorage/token)\" \\\n     --data '{ \"jsonrpc\": \"2.0\", \"method\": \"Filecoin.ChainHead\", \"params\": [], \"id\": 3 }' \\\n     'http://127.0.0.1:1234/rpc/v0'\n```\n\n> In the future we will add a playground to make it easier to build and experiment with API requests.\n\n## CURL authorization\n\nTo authorize your request, you will need to include the **JWT** in a HTTP header, for example:\n\n```sh\n-H \"Authorization: Bearer $(cat ~/.lotusstorage/token)\"\n```\n\nAdmin token is stored in `~/.lotus/token` for the **Lotus Node** or `~/.lotusstorage/token` for the **Lotus Storage Miner**.\n\n## How do I generate a token?\n\nTo generate a JWT with custom permissions, use this command:\n\n```sh\n# Lotus Node\nlotus auth create-token --perm admin\n\n# Lotus Storage Miner\nlotus-storage-miner auth create-token --perm admin\n```\n\n## What authorization level should I use?\n\nWhen viewing [api/apistruct/struct.go](https://github.com/filecoin-project/lotus/blob/master/api/apistruct/struct.go), you will encounter these types:\n\n- `read` - Read node state, no private data.\n- `write` - Write to local store / chain, and `read` permissions.\n- `sign` - Use private keys stored in wallet for signing, `read` and `write` permissions.\n- `admin` - Manage permissions, `read`, `write`, and `sign` permissions.\n","posts":[{"title":"Remote API Support","slug":"en+api-scripting-support","github":"en/api-scripting-support.md","value":"# Remote API Support\n\nYou may want to delegate the work **Lotus Storage Miner** or **Lotus Node** performs to other machines. \nHere is how to setup the necessary authorization and environment variables.\n\n## Environment variables\n\nEnvironmental variables are variables that are defined for the current shell and are inherited by any child shells or processes. Environmental variables are used to pass information into processes that are spawned from the shell.\n\nUsing the [JWT you generated](https://lotu.sh/en+api#how-do-i-generate-a-token-18865), you can assign it and the **multiaddr** to the appropriate environment variable.\n\n```sh\n# Lotus Node\nFULLNODE_API_INFO=\"JWT_TOKEN:/ip4/127.0.0.1/tcp/1234/http\"\n\n# Lotus Storage Miner\nSTORAGE_API_INFO=\"JWT_TOKEN:/ip4/127.0.0.1/tcp/2345/http\"\n```\n\nYou can also use `lotus auth api-info --perm admin` to quickly create _API_INFO env vars\n\n- The **Lotus Node**'s `mutliaddr` is in `~/.lotus/api`.\n- The default token is in `~/.lotus/token`.\n- The **Lotus Storage Miner**'s `multiaddr` is in `~/.lotusstorage/config`.\n- The default token is in `~/.lotusstorage/token`.\n"},{"title":"API Troubleshooting","slug":"en+api-troubleshooting","github":"en/api-troubleshooting.md","value":"# API Troubleshooting\n\n## Types: params\n\n`params` must be an array. If there are no `params` you should still pass an empty array.\n\n## Types: TipSet\n\nFor methods such as `Filecoin.StateMinerPower`, where the method accepts the argument of the type `TipSet`, you can pass `null` to use the current chain head.\n\n```sh\ncurl -X POST \\\n     -H \"Content-Type: application/json\" \\\n     --data '{ \"jsonrpc\": \"2.0\", \"method\": \"Filecoin.StateMinerPower\", \"params\": [\"t0101\", null], \"id\": 3 }' \\\n     'http://127.0.0.1:1234/rpc/v0'\n```\n\n## Types: Sending a CID\n\nIf you do not serialize the CID as a [JSON IPLD link](https://did-ipid.github.io/ipid-did-method/#txref), you will receive an error. Here is an example of a broken CURL request:\n\n```sh\ncurl -X POST \\\n     -H \"Content-Type: application/json\" \\\n     --data '{ \"jsonrpc\": \"2.0\", \"method\":\"Filecoin.ClientGetDealInfo\", \"params\": [\"bafyreiaxl446wlnu6t6dpq4ivrjf4gda4gvsoi4rr6mpxau7z25xvk5pl4\"], \"id\": 0 }' \\\n     'http://127.0.0.1:1234/rpc/v0'\n```\n\nTo fix it, change the `params` property to:\n\n```sh\ncurl -X POST \\\n     -H \"Content-Type: application/json\" \\\n     --data '{ \"jsonrpc\": \"2.0\", \"method\":\"Filecoin.ClientGetDealInfo\", \"params\": [{\"/\": \"bafyreiaxl446wlnu6t6dpq4ivrjf4gda4gvsoi4rr6mpxau7z25xvk5pl4\"}], \"id\": 0 }' \\\n     'http://127.0.0.1:1234/rpc/v0'\n```\n"}]},{"title":"Developer Tools","slug":"en+dev-tools","github":"en/dev-tools.md","value":"# Developer Tools\n\n> Running a local network can be a great way to understand how Lotus works and test your setup. \n","posts":[{"title":"Setup Local Devnet","slug":"en+setup-local-dev-net","github":"en/local-dev-net.md","value":"# Setup Local Devnet\n\nBuild the Lotus Binaries in debug mode, This enables the use of 2048 byte sectors.\n\n```sh\nmake 2k\n```\n\nDownload the 2048 byte parameters:\n```sh\n./lotus fetch-params 2048\n```\n\nPre-seal some sectors:\n\n```sh\n./lotus-seed pre-seal --sector-size 2KiB --num-sectors 2\n```\n\nCreate the genesis block and start up the first node:\n\n```sh\n./lotus-seed genesis new localnet.json\n./lotus-seed genesis add-miner localnet.json ~/.genesis-sectors/pre-seal-t01000.json\n./lotus daemon --lotus-make-genesis=dev.gen --genesis-template=localnet.json --bootstrap=false\n```\n\nThen, in another console, import the genesis miner key:\n\n```sh\n./lotus wallet import ~/.genesis-sectors/pre-seal-t01000.key\n```\n\nSet up the genesis miner:\n\n```sh\n./lotus-storage-miner init --genesis-miner --actor=t01000 --sector-size=2KiB --pre-sealed-sectors=~/.genesis-sectors --pre-sealed-metadata=~/.genesis-sectors/pre-seal-t01000.json --nosync\n```\n\nNow, finally, start up the miner:\n\n```sh\n./lotus-storage-miner run --nosync\n```\n\nIf all went well, you will have your own local Lotus Devnet running.\n","posts":[]},{"title":"Jaeger Tracing","slug":"en+dev-tools-jaeger-tracing","github":"en/dev-tools-jaeger-tracing.md","value":"# Jaeger Tracing\n\nLotus has tracing built into many of its internals. To view the traces, first download [Jaeger](https://www.jaegertracing.io/download/) (Choose the 'all-in-one' binary). Then run it somewhere, start up the lotus daemon, and open up localhost:16686 in your browser.\n\n## Open Census\n\nLotus uses [OpenCensus](https://opencensus.io/) for tracing application flow. This generates spans through the execution of annotated code paths.\n\nCurrently it is set up to use Jaeger, though other tracing backends should be fairly easy to swap in.\n\n## Running Locally\n\nTo easily run and view tracing locally, first, install jaeger. The easiest way to do this is to [download the binaries](https://www.jaegertracing.io/download/) and then run the `jaeger-all-in-one` binary. This will start up jaeger, listen for spans on `localhost:6831`, and expose a web UI for viewing traces on `http://localhost:16686/`.\n\nNow, to start sending traces from Lotus to Jaeger, set the environment variable `LOTUS_JAEGER` to `localhost:6831`, and start the `lotus daemon`.\n\nNow, to view any generated traces, open up `http://localhost:16686/` in your browser.\n\n## Adding Spans\n\nTo annotate a new codepath with spans, add the following lines to the top of the function you wish to trace:\n\n```go\nctx, span := trace.StartSpan(ctx, \"put function name here\")\ndefer span.End()\n```\n","posts":[]}]},{"title":"FAQs","slug":"en+faqs","github":"en/faqs.md","value":"# Frequently Asked Questions\n\nHere are some FAQs concerning the Lotus implementation and participation in \nTestnet.\nFor questions concerning the broader Filecoin project, please \ngo [here](https://filecoin.io/faqs/).\n\n## Introduction to Lotus\n\n### What is Lotus?\n\nLotus is an implementation of the **Filecoin Distributed Storage Network**, written in Go. \nIt is designed to be modular and interoperable with any other implementation of the Filecoin Protocol.\nMore information about Lotus can be found [here](https://lotu.sh/).\n\n### What are the components of Lotus?\n\nLotus is composed of two separate pieces that can talk to each other:\n\nThe Lotus Node can sync the blockchain, validating all blocks, transfers, and deals\nalong the way. It can also facilitate the creation of new storage deals. If you are not \ninterested in providing your own storage to the network, and do not want to produce blocks\nyourself, then the Lotus Node is all you need!\n\nThe Lotus Storage Miner does everything you need for the registration of storage, and the\nproduction of new blocks. The Lotus Storage Miner communicates with the network\nby talking to a Lotus Node over the JSON-RPC API.\n\n## Setting up a Lotus Node\n\n### How do I set up a Lotus Node?\n\nFollow the instructions found [here](https://docs.lotu.sh/en+getting-started).\n\n### Where can I get the latest version of Lotus?\n\nDownload the binary tagged as the `Latest Release` from the\n [Lotus Github repo](https://github.com/filecoin-project/lotus/releases).\n \n### What operating systems can Lotus run on?\n\nLotus can build and run on most Linux and MacOS systems with at least \n8GB of RAM. Windows is not yet supported.\n\n### How can I update to the latest version of Lotus?\n\nTo update Lotus, follow the instructions [here](https://lotu.sh/en+updating-lotus).\n\n### How do I prepare a fresh installation of Lotus?\n\nStop the Lotus daemon, and delete all related files, including sealed and chain data by \nrunning `rm ~/.lotus ~/.lotusstorage`.\n\nThen, install Lotus afresh by following the instructions \nfound [here](https://docs.lotu.sh/en+getting-started).\n\n## Interacting with a Lotus Node\n\n### How can I communicate with a Lotus Node?\n\nLotus Nodes have a command-line interface, as well as a JSON-RPC API.\n\n### What are the commands I can send using the command-line interface? \n\nThe command-line interface is self-documenting, try running `lotus --help` from the `lotus` home \ndirectory for more.\n\n### How can I send a request over the JSON-RPC API?\n\nInformation on how to send a `cURL` request to the JSON-RPC API can be found\n[here](https://lotu.sh/en+api). A JavaScript client is under development.\n\n### What are the requests I can send over the JSON-RPC API?\n\nPlease have a look at the \n[source code](https://github.com/filecoin-project/lotus/blob/master/api/api_full.go) \nfor a list of methods supported by the JSON-RPC API.\n## The Test Network\n\n### What is Testnet?\n\nTestnet is a live network of Lotus Nodes run by the \ncommunity for testing purposes.\n It has 2 PiB of storage (and growing!) dedicated to it.\n\n### Is FIL on the Testnet worth anything?\n\nNothing at all! Real-world incentives may be provided in a future phase of Testnet, but this is \nyet to be confirmed.\n\n### How can I see the status of Testnet?\n\nThe [dashboard](https://stats.testnet.filecoin.io/) displays the status of the network as \nwell as a ton\nof other metrics you might find interesting.\n\n## Mining with a Lotus Node on Testnet\n\n### How do I get started mining with Lotus?\n\nFollow the instructions found [here](https://lotu.sh/en+mining).\n\n### What are the minimum hardware requirements?\n\nAn example test configuration, and minimum hardware requirements can be found \n[here](https://lotu.sh/en+hardware-mining). \n\nNote that these might NOT be the minimum requirements for mining on Mainnet.\n\n### What are some GPUs that have been tested?\n\nA list of benchmarked GPUs can be found [here](https://lotu.sh/en+hardware-mining#benchmarked-gpus-7393).\n\n### Why is my GPU not being used when sealing a sector?\n\nSealing a sector does not involve constant GPU operations. It's possible\nthat your GPU simply isn't necessary at the moment you checked.\n\n## Advanced questions\n\n### Is there a Docker image for lotus?\n\nCommunity-contributed Docker and Docker Compose examples are available \n[here](https://github.com/filecoin-project/lotus/tree/master/tools/dockers/docker-examples).\n\n### How can I run two miners on the same machine?\n\nYou can do so by changing the storage path variable for the second miner, e.g.,\n`LOTUS_STORAGE_PATH=~/.lotusstorage2`. You will also need to make sure that no ports collide.\n\n### How do I setup my own local devnet?     \n\nFollow the instructions found [here](https://lotu.sh/en+setup-local-dev-net).\n\n### Are there any other implementations of Filecoin?\n\nYes! Check out the [go-filecoin](https://github.com/filecoin-project/go-filecoin#filecoin-go-filecoin)\nimplementation, which is fully interoperable with Lotus!\n","posts":[]},{"title":"Glossary","slug":"en+glossary","github":"en/.glossary.json","value":null,"custom":{"glossary":true},"posts":[]}],"glossary":{"bellman":{"title":"Bellman","value":"Bellman is a rust crate for building zk-SNARK circuits. It provides circuit traits and primitive structures, as well as basic gadget implementations such as booleans and number abstractions."},"nvme":{"title":"NVMe","value":"(non-volatile memory express) is a host controller interface and storage protocol created to accelerate the transfer of data between enterprise and client systems and solid-state drives (SSDs) over a computer's high-speed Peripheral Component Interconnect Express (PCIe) bus."},"multiaddr":{"title":"Multiaddr","value":"Multiaddr is a format for encoding addresses from various well-established network protocols. It is useful to write applications that future-proof their use of addresses, and allow multiple transport protocols and addresses to coexist."},"attofil":{"title":"attoFIL","value":"AttoFIL is a word used to describe 10^-18 FIL. The word atto comes from the Norwegian and Danish term: atten eighteen."},"fil":{"title":"FIL","value":"A ticker symbol is an abbreviation used to uniquely identify Filecoin when it is used in a wallet exchange or a cryptocurrency exchange."},"epost":{"title":"Election Proof-of-Spacetime","value":"Election Proof-of-Spacetime couples the Proof-of-Spacetime process with block production, meaning that in order to produce a block, the miner must produce a valid Proof-of-Spacetime proof (snark output)."},"jwt":{"title":"JWT","value":"JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties."},"json-rpc":{"title":"JSON-RPC","value":"JSON-RPC is a remote procedure call protocol encoded in JSON. It is a very simple protocol (and very similar to XML-RPC), defining only a few data types and commands."},"bls-address":{"title":"BLS Signature (Address)","value":"A Bonehâ€“Lynnâ€“Shacham (BLS) signature is a digital signature scheme that allows a user to determine the authenticity of a signer, and is a commonly used signature scheme in the Filecoin Distributed Storage Network."},"faucet":{"title":"Filecoin Test Faucet","value":"A webpage where you can get free test Filecoin to participate in the Testnet."},"chain":{"title":"Chain","value":"The Filecoin Blockchain is a distributed virtual machine that achieves consensus, processes messages, accounts for storage, and maintains security in the Filecoin Protocol. It is the main interface linking various actors in the Filecoin system."},"miner-power":{"title":"Miner Power","value":"Miner storage in relation to network storage, tracked in the power table."},"sector":{"title":"Sector","value":"A fixed-size block of data of SECTOR_SIZE bytes which generally contains client's data."},"sealing":{"title":"Sealing","value":"A slow encoding process that returns commitments and proofs for data being stored in a sector."},"seal":{"title":"Seal","value":"A slow encoding process that returns commitments and proofs for data being stored in a sector."},"posts":{"title":"Proof-of-Spacetime(s)","value":"Filecoin is a protocol token whose blockchain runs on a novel proof, called Proof-of-Spacetime, where blocks are created by miners that are storing data."},"filecoin-testnet":{"title":"Filecoin Testnet","value":"Until we launch, we are making lots of changes to Lotus. The Testnet is expected to bring a few significant fixes/improvements. During Testnet, you can retrieve test filecoin from our network faucet to use as collateral to start mining. Test filecoin do not have any value â€“ the official filecoin tokens will not be released until Mainnet launch."},"filecoin-decentralized-storage-market":{"title":"Filecoin Decentralized Storage Market","value":"Storage Market subsystem is the data entry point into the network. Storage miners only earn power from data stored in a storage deal and all deals live on the Filecoin network."},"filecoin-proof-parameters":{"title":"Filecoin Proof Parameters","value":"The proving algorithms rely on a large binary parameter file."},"lotus-devnet":{"title":"DevNet","value":"On the DevNets, you can store data as a storage client and also try how Filecoin mining works. The devnets are an important development tool for those who anticipate building applications on top of the Filecoin protocol or storing data on the decentralized storage market. "},"filecoin-distributed-storage-network":{"title":"Filecoin Distributed Storage Network","value":"Filecoin is a distributed storage network based on a blockchain mechanism. Filecoin miners can elect to provide storage capacity for the network, and thereby earn units of the Filecoin cryptocurrency (FIL) by periodically producing cryptographic proofs that certify that they are providing the capacity specified."},"lotus-node":{"title":"Lotus Node","value":"The Lotus Node is full of capabilities. It runs the Blockchain system, makes retrieval deals, does data transfer, supports block producer logic, and syncs and validates the chain."},"block-rewards":{"title":"Block Reward","value":"Over the entire lifetime of the protocol, 1,400,000,000 FIL (TotalIssuance) will be given out to miners. The rate at which the funds are given out is set to halve every six years, smoothly (not a fixed jump like in Bitcoin)."},"block-producer-miner":{"title":"Miner (Block Producer)","value":"The Block Producer Miner's logic. It currently shares an interface and process with the Lotus Node. A Block Producer chooses which messages to include in a block and is rewarded according to each messageâ€™s gas price and consumption, forming a market."},"lotus-storage-miner":{"title":"Storage Miner (lotus-storage-miner)","value":"The Storage Miner's logic. It has its own dedicated process. Contributes to the network through Sector commitments and Proofs of Spacetime to prove that it is storing the sectors it has commited to."},"swarm-port":{"title":"Swarm Port (Libp2p)","value":"The LibP2P Swarm manages groups of connections to peers, handles incoming and outgoing streams, and is part of the storage miners implementation. The port value is part of the Host interface."},"daemon":{"title":"Lotus Daemon","value":"A Daemon is a program that runs as a background process. A Daemon in the context of the Filecoin Distributed Storage Network may enable applications to communicate with peers, handle protocols, participate in pubsub, and interact with a distributed hash table (DHT)."},"storage-deal":{"title":"Storage deal","value":"One of the two types of deals in Filecoin markets. Storage deals are recorded on the blockchain and enforced by the protocol."},"retrieval-deal":{"title":"Retrieval deal","value":"One of the two types of deals in Filecoin markets. Retrieval deals are off chain and enabled by micropayment channel by transacting parties."},"deal-cid":{"title":"Deal CID","value":"CID is a format for referencing content in distributed information systems, it is a way to store information so it can be retrieved based on its content, not its location. DealCID specifically is used in storage deals."},"data-cid":{"title":"Data CID","value":"CID is a format for referencing content in distributed information systems, it is a way to store information so it can be retrieved based on its content, not its location. DataCID specifically is used to represent the file that is stored in the Filecoin Distributed Storage Network."},"cid":{"title":"CID","value":"A CID is a self-describing content-addressed identifier. It uses cryptographic hashes to achieve content addressing. It uses several multiformats to achieve flexible self-description, namely multihash for hashes, multicodec for data content types, and multibase to encode the CID itself into strings."},"total-network-power":{"title":"Total Network Power","value":"A reference to all the Power Tables for every subchain, accounting for each Lotus Storage Miner on chain."},"chain-block-height":{"title":"Chain Block Height","value":"Chain block height is defined as the number of blocks in the chain between any given block and the very first block in the blockchain."},"block-height":{"title":"Block Height","value":"Height of the Merkle Tree of a sector. A sector is a contiguous array of bytes that a miner puts together, seals, and performs Proofs of Spacetime on."},"blocktime":{"title":"Blocktime","value":"The time it takes for a Block to propagate to the whole network."}}}